#include <vector>
#include <iostream>
#include <climits>

class Solution {
public:
  bool isRectangleCover(std::vector<std::vector<int>>& rectangles) {
    int max_blx = INT_MAX, max_bly = INT_MAX, max_brx = INT_MIN, max_bry = INT_MAX, max_tlx = INT_MAX, max_tly = INT_MIN, max_trx = INT_MIN, max_try = INT_MIN;
    for (auto& i : rectangles) {
      if (i[0] <= max_blx && i[1] <= max_bly) {
        max_blx = i[0];
        max_bly = i[1];
      }
      if (i[0] >= max_brx && i[1] <= max_bry) {
        max_brx = i[0];
        max_bry = i[1];
      }
      if (i[0] <= max_tlx && i[1] >= max_tly) {
        max_tlx = i[0];
        max_tly = i[1];
      }
      if (i[0] >= max_trx && i[1] >= max_try) {
        max_trx = i[0];
        max_try = i[1];
      }

      if (i[2] <= max_blx && i[3] <= max_bly) {
        max_blx = i[2];
        max_bly = i[3];
      }
      if (i[2] >= max_brx && i[3] <= max_bry) {
        max_brx = i[2];
        max_bry = i[3];
      }
      if (i[2] <= max_tlx && i[3] >= max_tly) {
        max_tlx = i[2];
        max_tly = i[3];
      }
      if (i[2] >= max_trx && i[3] >= max_try) {
        max_trx = i[2];
        max_try = i[3];
      }
    }

    if (max_blx != max_tlx || max_brx != max_trx || max_bly != max_bry || max_tly != max_try) return false;

    std::vector<std::vector<int>> counts(std::max(max_brx, max_trx) - std::min(max_blx, max_tlx) + 1, std::vector<int>(std::max(max_bry, max_try) - std::min(max_bly, max_tly) + 1, 0));
    for (auto &rect : rectangles) {
      for (int i = rect[0]; i <= rect[2]; i++) {
        for (int j = rect[1]; j <= rect[3]; j++) {
          counts[i][j]++;
        }
      }
    }

    for (int i = max_blx; i <= max_trx; i++) {
      for (int j = max_bly; j <= max_try; j++) {
        if (counts[i][j] != 1) return false;
      }
    }

    return true;
  }
};

int main(int argc, char *argv[]) {
  std::vector<std::vector<int>> rects = {{1, 1, 3, 3}, {3, 1, 4, 2}, {3, 2, 4, 4}, {1, 3, 2, 4}, {2, 3, 3, 4}};
  Solution s;
  std::cout << std::boolalpha << s.isRectangleCover(rects) << '\n';
  
  return 0;
}
