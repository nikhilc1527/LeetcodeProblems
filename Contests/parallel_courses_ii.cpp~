  class Graph {
  public:
    int V;
  
    std::list<int>* adj; 
  
    void topologicalSortUtil(int v, bool visited[], std::stack<int>& Stack) {
      visited[v] = true; 
  
      std::list<int>::iterator i; 
      for (i = adj[v].begin(); i != adj[v].end(); ++i) 
	if (!visited[*i]) 
	  topologicalSortUtil(*i, visited, Stack); 
  
      Stack.push(v); 
    }
  
    Graph(int V) {
      this->V = V; 
      adj = new std::list<int>[V]; 
    }
  
    void addEdge(int v, int w) {
      adj[v].push_back(w);
    }
  
    void top(std::vector<int> sorted) {
      std::stack<int> Stack; 
  
      bool* visited = new bool[V]; 
      for (int i = 0; i < V; i++) 
	visited[i] = false; 
  
      for (int i = 0; i < V; i++) 
	if (visited[i] == false) 
	  topologicalSortUtil(i, visited, Stack); 
  
      while (Stack.empty() == false) {
	sorted.push_back(Stack.top());
	Stack.pop();
      } 
    }
  }; 

  int minNumberOfSemesters(int n, std::vector<std::vector<int>>& dep, int k) {
    Graph g(n);
    std::vector<int> sorted;
    g.top(sorted);
    std::unordered_map<int, int> indices;
    for (int i = 0; i < n; i++) {
      indices[sorted[i]] = i;
    }

    std::vector<bool> available(n, true);
    int i = 0;
    int sems = 0;
    while (i < n) {
      for (int j = i + 1; j < k && available[j]; j++) {
	for (auto &l : g.adj[sorted[j]])
	  available[indices[l]] = false;
	i++;
      }
      sems++;
      available = std::vector<bool>(n, true);
    }
    return sems;
  }
